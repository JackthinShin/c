<!--Version:1.1.13-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>C 语言在线编译器 | HCY ZJU</title>
    <!-- 字体图标和 Monaco 加载器 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.js"></script>

    <!-- Highlight.js themes (prefetch links; actual enable/disable handled by script) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css" id="hljs-theme-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css" id="hljs-theme-light" disabled>

    <style>
        /* 暗黑优先 - 极简 mac 风格 */
        :root{
            --sidebar-width: 380px;
            --bg: #0b0c0d;           /* 页面背景（near black） */
            --panel: #0f1113;        /* 卡片 / 主容器背景 */
            --muted: #9aa4ad;        /* 次要文字 */
            --accent: #48a0ff;       /* 高亮色（适度） */
            --glass: rgba(255,255,255,0.02);
            --radius: 10px;
            --shadow: 0 8px 30px rgba(0,0,0,0.6);
        }

        /* 明亮主题覆盖变量（切换时将 body 添加 .light-theme） */
        .light-theme{
            --bg: #f3f6fb;
            --panel: #ffffff;
            --muted: #6b7280;
            --accent: #2563eb;
            --glass: rgba(0,0,0,0.03);
            --shadow: 0 10px 30px rgba(16,24,40,0.06);
        }

        *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    body{background:var(--bg);color:var(--muted);transition:background-color .45s ease,color .45s ease}

        /* 应用容器：占满整个视口，类似本地 app 的全屏编辑器 */
        .app{height:100vh;width:100vw;display:flex;flex-direction:column;align-items:stretch;justify-content:stretch}
    .frame{max-width:1400px;margin:12px auto;flex:1;background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;display:flex;flex-direction:column;transition:background-color .45s ease,box-shadow .45s ease;min-height:0;width:100%}

    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);transition:background-color .45s ease}
        header .title{display:flex;align-items:center;gap:10px;font-weight:600}
        header .title i{color:var(--accent);font-size:18px}
    header .meta{color:var(--muted);font-size:13px}
    header .meta a{color:var(--muted);text-decoration:none;display:inline-flex;align-items:center;gap:6px;cursor:pointer}
    header .meta a:hover{color:var(--accent);text-decoration:underline}

    /* 主区：编辑器 + 侧栏 */
    .main{flex:1;display:flex;min-height:0;position:relative}

        /* 编辑区 */
    .editor-wrap{flex:1;display:flex;flex-direction:column;border-right:1px solid rgba(0,0,0,0.06);transition:background-color .4s ease,border-color .4s ease;z-index:5;min-height:0}
    .editor-head{display:flex;align-items:center;justify-content:space-between;padding:10px 14px}
    .editor-head h2{font-size:14px;color:#dbe9ff}
    #editor{flex:1;min-height:0;height:100%}

        /* 工具栏 */
        .toolbar{display:flex;gap:8px;padding:10px 14px;align-items:center}
    .btn{border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;display:inline-flex;align-items:center;gap:8px;background:transparent;color:var(--muted);transition:color .3s}
    .btn.primary{background:var(--accent);color:#071022}
    .btn.ghost{border:1px solid rgba(0,0,0,0.06)}

    /* 侧栏 */
    /* 侧栏：使用绝对定位以覆盖编辑区，避免被 Monaco canvas 遮挡 */
    /* 侧栏：覆盖式定位，但保留顶部与底部间隔，避免遮挡 header 与 底部工具栏；JS 会在运行时计算精确的 top/bottom */
    .sidebar{width:var(--sidebar-width);display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);transition:width .28s ease,opacity .28s ease,padding .28s ease;position:absolute;right:0;top:56px;bottom:72px;z-index:1000}
    /* 折叠侧栏：设置宽度为0并隐藏内边距，编辑器会自动占满剩余空间 */
    .sidebar.collapsed{width:0;padding:0;opacity:0;pointer-events:none}
        .sb-head{display:flex;align-items:center;justify-content:space-between;padding:12px 14px}
        .sb-section{padding:12px 14px;flex:1;overflow:auto}
        textarea,input[type=text]{width:100%;padding:10px;border:1px solid rgba(255,255,255,0.03);border-radius:8px;background:transparent;color:#e6eef6;font-family:monospace}
        .output{background:var(--glass);color:#dfefff;padding:12px;border-radius:8px;white-space:pre-wrap;height:100%;overflow:auto;font-family:monospace}

    /* 悬浮的侧边栏切换按钮（当侧栏折叠时可恢复） */
    #sidebarToggle{position:fixed;right:18px;bottom:24px;width:44px;height:44px;border-radius:10px;background:var(--panel);border:1px solid rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center;color:var(--accent);box-shadow:var(--shadow);cursor:pointer;transition:opacity .2s;z-index:2000}

    /* 注意：编辑器保持始终填满宽度，侧栏是覆盖式的但上下有留白以避免遮挡头部与底部控件 */

        /* 小屏适配 */
        @media (max-width:900px){
            .main{flex-direction:column}
            .sidebar{width:100%;height:34%}
            .editor-wrap{border-right:0}
        }
        /* 使颜色切换更顺滑：对主要面板启用背景/颜色过渡 */
        .frame, header, .sidebar, .editor-wrap, .toolbar, .output { transition: background-color .45s ease, color .45s ease }
        /* 确保编辑器画布不挡住侧栏：编辑器区域的层级要低于侧栏 */
        #editor{position:relative;z-index:10}
    </style>
</head>
<body>
    <div class="app">
        <div class="frame">
        <header>
            <div class="title"><i class="fas fa-code"></i><div>Online C Compiler</div></div>
            <div class="meta">By C. He from ZJU · <a href="/CHANGELOG.md" target="_blank" rel="noopener" id="versionLink"><span id="versionTag">Version 1.1.14</span></a></div>
        </header>

        <div class="main">
            <div class="editor-wrap">
                <div class="editor-head">
                    <h2><i class="fas fa-file-code"></i> <span id="fileTitle">main.c</span></h2>
                    <div class="status" id="saveStatus">已保存</div>
                </div>

                <div id="editor"></div>

                <div class="toolbar">
                    <button class="btn primary" id="runBtn"><i class="fas fa-play"></i> 运行</button>
                    <button class="btn ghost" id="openFileBtn"><i class="fas fa-folder-open"></i> 打开文件</button>
                    <button class="btn ghost" id="saveBtn"><i class="fas fa-save"></i> 保存</button>
                    <button class="btn ghost" id="resetBtn"><i class="fas fa-undo"></i> 重置</button>
                    <button class="btn ghost" id="formatBtn" title="自动缩进"><i class="fas fa-indent"></i> 自动缩进</button>
                    <button class="btn ghost" id="fsBtn" title="全屏"><i class="fas fa-expand"></i></button>
                    <label style="display:inline-flex;align-items:center;gap:8px;color:var(--muted)">
                        <input type="checkbox" id="useWasm" style="width:16px;height:16px"> 优先使用 WASM
                    </label>
                    <div style="flex:1"></div>
                    <button class="btn ghost" id="saveAsBtn"><i class="fas fa-download"></i> 另存为</button>
                    <button class="btn ghost" id="themeBtn"><i class="fas fa-sun"></i> 主题</button>
                </div>
            </div>

            <aside class="sidebar" id="sidebar">
                <div class="sb-head"><div><i class="fas fa-terminal"></i> 运行结果</div><button id="closeSb" class="btn ghost">折叠</button></div>
                <div class="sb-section">
                    <label>输入 (stdin)</label>
                    <textarea id="stdin" rows="3" placeholder="例如：10 20"></textarea>
                    <div style="height:12px"></div>
                    <label>输出 (stdout)</label>
                    <div class="output" id="stdout">程序输出将显示在这里...</div>
                </div>
            </aside>
        </div>
        </div>
    </div>

    <!-- 折叠后恢复侧栏的悬浮按钮 -->
    <div id="sidebarToggle" title="打开侧栏"><i class="fas fa-chevron-left"></i></div>
    <!-- 隐藏的本地文件选择器 -->
    <input type="file" id="fileInput" accept=".c,.cpp,.h,.hpp,.txt" style="display:none" />

    <!-- Changelog modal (hidden by default) -->
    <div id="changelogModal" aria-hidden="true" style="display:none">
        <div class="changelog-sheet" role="dialog" aria-modal="true" aria-labelledby="changelogTitle">
            <button class="changelog-close" aria-label="关闭更新日志">✕</button>
            <div id="changelogContent"></div>
        </div>
    </div>

    <script>
        /**********************************************************************
         * 简洁版脚本：功能
         * - 初始化 Monaco 编辑器
         * - 本地保存/加载代码（localStorage）
         * - 简单运行（模拟 scanf/printf）
         * - 主题切换与 UI 状态更新
         * 所有注释为中文，便于维护。
         **********************************************************************/

        // 默认代码（保持与 UI 功能一致的示例）
        const DEFAULT_CODE = `#include <stdio.h>

int main() {
    printf("By ZJU C. He");
    return 0;
}`;

        // 编辑器脏标记（未保存状态）
        let isDirty = false;

        // DOM 引用
        const runBtn = document.getElementById('runBtn');
        const saveBtn = document.getElementById('saveBtn');
        const resetBtn = document.getElementById('resetBtn');
        const themeBtn = document.getElementById('themeBtn');
        const stdinEl = document.getElementById('stdin');
        const stdoutEl = document.getElementById('stdout');
        const saveStatus = document.getElementById('saveStatus');
        const closeSb = document.getElementById('closeSb');

        // Monaco 编辑器需要异步加载
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            // 尝试从 localStorage 加载之前保存的代码
            const saved = localStorage.getItem('deepseek_saved_c');
            window.editor = monaco.editor.create(document.getElementById('editor'), {
                value: saved || DEFAULT_CODE,
                language: 'c',
                theme: (localStorage.getItem('editorTheme') === 'light') ? 'vs-light' : 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 13,
                scrollBeyondLastLine: false
            });

            // 应用 body 主题类（持久化）
            try { if (localStorage.getItem('editorTheme') === 'light') document.body.classList.add('light-theme'); } catch (e) {}

            // 编辑器内容改变时标记为未保存（添加 '*'）
            try {
                window.editor.onDidChangeModelContent(() => {
                    if (!isDirty) setDirty(true);
                });
            } catch (e) {}

            // 快捷键：Ctrl/Cmd+S 保存
            window.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                    e.preventDefault(); saveCode();
                }
            });
        });

    // ----------------- 功能函数 -----------------
        // 保存当前编辑器内容到 localStorage，并提示状态
        function saveCode() {
            if (!window.editor) return;
            localStorage.setItem('deepseek_saved_c', window.editor.getValue());
            saveStatus.textContent = '已保存';
            saveStatus.style.color = '#22c55e';
            // 保存后取消脏标记
            setDirty(false);
            setTimeout(() => { saveStatus.style.color = ''; }, 1200);
        }

        // 将编辑器内容重置为默认代码（不会清除 localStorage）
        function resetCode() {
            if (!window.editor) return;
            if (!confirm('确定重置代码？未保存的更改将丢失。')) return;
            window.editor.setValue(DEFAULT_CODE);
            // 重置后视为未保存（需要用户保存以覆盖 localStorage）
            setDirty(true);
        }

        // runCode: 优先尝试 Wandbox（真实编译器），若失败尝试加载本地 WASM 运行器（若你已部署）
        // 最后回退到原有的模拟（simulateRun）。Wandbox API: https://wandbox.org
        async function tryWandboxCompile(code, stdin) {
            const wandboxUrl = 'https://wandbox.org/api/compile.json';
            const payload = {
                code,
                compiler: 'gcc-head', // 可改为 clang-head 或其他
                stdin: stdin || undefined,
                save: false
            };

            const fetchWithTimeout = (url, opts, timeout = 8000) => {
                return Promise.race([
                    fetch(url, opts),
                    new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))
                ]);
            };

            const resp = await fetchWithTimeout(wandboxUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }, 10000);

            if (!resp.ok) throw new Error('Wandbox 返回 ' + resp.status);
            const json = await resp.json();

            // Wandbox 返回字段不总是固定，常见有: program_output / program_error / compiler_output
            const out = (json.program_output || json.program_stdout || json.program || json.result || '') || '';
            const err = (json.program_error || json.program_stderr || json.compiler_error || json.compiler_output || '') || '';
            const status = json.status ?? 0;
            return { stdout: out, stderr: err, exitCode: status };
        }

        // 动态加载前端 WASM 运行器（如果你在 repo 下放置了 /wasm/tcc_runner.js）
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = url;
                s.onload = () => resolve();
                s.onerror = (e) => reject(new Error('加载失败: ' + url));
                document.head.appendChild(s);
            });
        }

        // 如果用户在仓库中放置了一个基于 tcc/clang 的 wasm 运行器并暴露 window.wasmRun(code, stdin)
        async function tryWasmRun(code, stdin) {
            // 常用路径：/wasm/tcc_runner.js（你需要把相应的脚本和 wasm 放到该路径）
            if (typeof window.wasmRun === 'function') {
                return await window.wasmRun(code, stdin);
            }

            // 尝试动态加载预期的脚本（如果你已上传）
            try {
                await loadScript('/wasm/tcc_runner.js');
                if (typeof window.wasmRun === 'function') {
                    return await window.wasmRun(code, stdin);
                } else {
                    throw new Error('wasmRun 未在脚本中暴露');
                }
            } catch (e) {
                throw e;
            }
        }

        async function runCode() {
            if (!window.editor) return;
            const code = window.editor.getValue();
            const stdin = (stdinEl.value || '').trim();

            const preferWasm = !!document.getElementById('useWasm') && document.getElementById('useWasm').checked;
            if (preferWasm) stdoutEl.textContent = '运行中（优先尝试浏览器端 WASM）...';
            else stdoutEl.textContent = '运行中（优先尝试 Wandbox）...';

            // 两种优先级：WASM 优先或 Wandbox 优先
            if (preferWasm) {
                // 1) 尝试 WASM
                try {
                    const wasmRes = await tryWasmRun(code, stdin);
                    let out = '';
                    if (wasmRes.stdout) out += wasmRes.stdout;
                    if (wasmRes.stderr) out += '\n[stderr]\n' + wasmRes.stderr;
                    out += `\n[exit code] ${wasmRes.exitCode ?? 0}`;
                    stdoutEl.textContent = out.trim();
                    return;
                } catch (e) {
                    console.warn('WASM 运行器不可用：', e);
                    stdoutEl.textContent = 'WASM 不可用，尝试 Wandbox（若可用）...';
                }

                // 2) 尝试 Wandbox
                try {
                    const res = await tryWandboxCompile(code, stdin);
                    let out = '';
                    if (res.stdout) out += res.stdout;
                    if (res.stderr) out += '\n[stderr]\n' + res.stderr;
                    out += `\n[exit code] ${res.exitCode ?? 0}`;
                    stdoutEl.textContent = out.trim();
                    return;
                } catch (e) {
                    console.warn('Wandbox 调用失败：', e);
                    stdoutEl.textContent = 'Wandbox 不可用或被阻止，回退到本地模拟。';
                }
            } else {
                // Wandbox 优先
                try {
                    const res = await tryWandboxCompile(code, stdin);
                    let out = '';
                    if (res.stdout) out += res.stdout;
                    if (res.stderr) out += '\n[stderr]\n' + res.stderr;
                    out += `\n[exit code] ${res.exitCode ?? 0}`;
                    stdoutEl.textContent = out.trim();
                    return;
                } catch (e) {
                    console.warn('Wandbox 调用失败：', e);
                    stdoutEl.textContent = 'Wandbox 不可用或被阻止，尝试 WASM（若已部署）...';
                }

                try {
                    const wasmRes = await tryWasmRun(code, stdin);
                    let out = '';
                    if (wasmRes.stdout) out += wasmRes.stdout;
                    if (wasmRes.stderr) out += '\n[stderr]\n' + wasmRes.stderr;
                    out += `\n[exit code] ${wasmRes.exitCode ?? 0}`;
                    stdoutEl.textContent = out.trim();
                    return;
                } catch (e) {
                    console.warn('WASM 运行器不可用：', e);
                    stdoutEl.textContent = '本地 WASM 运行器不可用，回退到本地模拟。';
                }
            }

            // 最后回退到模拟
            simulateRun(code, stdin);
        }

        // 本地回退：简单模拟 scanf/printf 行为（仅作演示）
        function simulateRun(code, input) {
            stdoutEl.textContent = '本地模拟运行...';
            setTimeout(() => {
                if (/scanf\s*\(/.test(code) && (!input || input.trim() === '')) {
                    stdoutEl.textContent = '错误：程序需要输入但未提供 stdin。';
                    return;
                }

                if (!input || input.trim() === '') {
                    stdoutEl.textContent = '提示：请在左侧输入两个整数，例如：10 20';
                    return;
                }

                const parts = input.split(/\s+/).map(s => parseInt(s, 10));
                if (parts.length >= 2 && parts.every(n => Number.isFinite(n))) {
                    const [a, b] = parts;
                    stdoutEl.textContent = `两数之和为：${a + b}`;
                } else {
                    stdoutEl.textContent = '错误：输入格式不正确，请输入两个整数（例如：10 20）';
                }
            }, 300);
        }

        // 切换主题（轻/暗），默认暗黑。我们通过 body 的 .light-theme 类切换 CSS 变量
        // 主题持久化到 localStorage: 'editorTheme' = 'dark' | 'light'
        let isDark = true;
        // 读取持久化主题（若存在）
        try {
            const stored = localStorage.getItem('editorTheme');
            if (stored) isDark = stored === 'dark';
        } catch (e) {}

        function applyThemeImmediately() {
            document.body.classList.toggle('light-theme', !isDark);
            try { if (window.monaco) monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light'); } catch (e) {}
            themeBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i> 明亮' : '<i class="fas fa-moon"></i> 暗色';
        }

        function toggleTheme() {
            isDark = !isDark;
            // 持久化
            try { localStorage.setItem('editorTheme', isDark ? 'dark' : 'light'); } catch (e) {}
            // 添加/移除全局类以切换 CSS 变量（平滑过渡）
            document.body.classList.toggle('light-theme', !isDark);
            // 更新按钮文案并在短延迟后切换 Monaco 主题，避免强烈反差
            themeBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i> 明亮' : '<i class="fas fa-moon"></i> 暗色';
            try {
                setTimeout(() => {
                    monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light');
                }, 180);
            } catch (e) {}
        }

    // ----------------- 事件绑定 -----------------
    // 常规绑定（若此时元素存在）
    try { runBtn && runBtn.addEventListener('click', runCode); } catch (e) {}
    try { saveBtn && saveBtn.addEventListener('click', saveCode); } catch (e) {}
    try { resetBtn && resetBtn.addEventListener('click', resetCode); } catch (e) {}
    try { themeBtn && themeBtn.addEventListener('click', toggleTheme); } catch (e) {}
    // 自动缩进按钮绑定
    try {
        const formatBtn = document.getElementById('formatBtn');
        if (formatBtn) {
            formatBtn.addEventListener('click', function() {
                if (window.editor) {
                    window.editor.getAction('editor.action.formatDocument').run();
                }
            });
        }
    } catch (e) {}

        // 侧栏折叠/展开逻辑：使用 class 'collapsed'，便于动画与恢复
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const editorWrap = document.querySelector('.editor-wrap');
        closeSb.addEventListener('click', () => {
            sidebar.classList.add('collapsed');
            sidebarToggle.style.display = 'flex';
            // 折叠侧栏时不改变编辑器宽度（编辑器始终填满宽度），仅触发布局
            try { editorWrap && editorWrap.classList.add('full'); } catch (e) {}
            setTimeout(() => { try { window.editor && window.editor.layout(); } catch (e) {} }, 320);
        });
        sidebarToggle.addEventListener('click', () => {
            // 展开侧栏：先移除 collapsed，使其恢复到正常宽度
            sidebar.classList.remove('collapsed');
            // 强制一次重排以确保浏览器应用宽度变化（防止 Monaco 的 canvas 覆盖侧栏）
            // 读取 offsetWidth 会触发回流
            try { void sidebar.offsetWidth; } catch (e) {}
            // 隐藏恢复按钮
            sidebarToggle.style.display = 'none';
            // 恢复侧栏显示后只需触发布局，编辑器仍保持填满宽度
            try { editorWrap && editorWrap.classList.remove('full'); } catch (e) {}
            // 立即触发一次布局以快速响应，稍后 transitionend 会触发最终布局
            try { window.editor && window.editor.layout(); } catch (e) {}
            setTimeout(() => { try { window.editor && window.editor.layout(); } catch (e) {} }, 180);
        });

        // 当侧栏过渡结束时，确保编辑器做最终布局（避免动画中 canvas 与侧栏出现错位）
        try {
            sidebar.addEventListener('transitionend', (ev) => {
                const prop = (ev && ev.propertyName) || '';
                if (prop.includes('width') || prop.includes('margin') || prop.includes('right') || prop.includes('opacity')) {
                    try { window.editor && window.editor.layout(); } catch (e) {}
                }
            });
        } catch (e) {}

        // 监听侧栏的折叠/展开和窗口尺寸以动态调整侧栏的上下边界，保证不遮挡头部与底部控件
        try {
            function adjustSidebarVertical() {
                try {
                    const headerEl = document.querySelector('header');
                    const toolbarEl = document.querySelector('.toolbar');
                    if (!headerEl || !toolbarEl) return;
                    const headerRect = headerEl.getBoundingClientRect();
                    const toolbarRect = toolbarEl.getBoundingClientRect();
                    // 计算顶部距离：将侧栏顶边放在 header 底部 + 8px 间隔
                    const topPx = Math.max(8, Math.round(headerRect.bottom + 8));
                    // 计算底部距离：将侧栏底边放在 toolbar 顶部 - 8px 间隔
                    const bottomPx = Math.max(8, Math.round(window.innerHeight - toolbarRect.top + 8));
                    sidebar.style.top = topPx + 'px';
                    sidebar.style.bottom = bottomPx + 'px';
                } catch (e) {}
            }
            // 初始调整
            adjustSidebarVertical();
            // 在窗口调整时重新计算
            window.addEventListener('resize', adjustSidebarVertical);
            // 在侧栏折叠/展开后也调整（transitionend 也会触发 editor.layout）
            sidebar.addEventListener('transitionend', adjustSidebarVertical);
            // 当用户点击折叠/展开按钮后立即调整并触发布局
            closeSb.addEventListener('click', () => { try { adjustSidebarVertical(); window.editor && window.editor.layout(); } catch (e) {} });
            sidebarToggle.addEventListener('click', () => { try { adjustSidebarVertical(); window.editor && window.editor.layout(); } catch (e) {} });
        } catch (e) {}

        // 更新脏标记 UI（文件名后显示 '*' 并更新保存状态）
        function setDirty(flag) {
            try {
                isDirty = !!flag;
                const title = currentFilename || 'main.c';
                fileTitle.textContent = title + (isDirty ? ' *' : '');
                saveStatus.textContent = isDirty ? '未保存' : '已保存';
                saveStatus.style.color = isDirty ? '#f59e0b' : '';
            } catch (e) {}
        }

    // 打开本地文件：触发隐藏的 file input，读取文本并替换编辑器内容
    const openFileBtn = document.getElementById('openFileBtn');
    const fileInput = document.getElementById('fileInput');
    const fileTitle = document.getElementById('fileTitle');
    const saveAsBtn = document.getElementById('saveAsBtn');
    let currentFilename = 'main.c';
        openFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (ev) => {
            const f = ev.target.files && ev.target.files[0];
            if (!f) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                // 如果当前编辑器内容与已保存的不一致，提醒用户
                try {
                    const current = window.editor ? window.editor.getValue() : '';
                    const saved = localStorage.getItem('deepseek_saved_c') || '';
                    if (current !== saved) {
                        const ok = confirm('当前编辑器中有未保存的更改，打开本地文件将覆盖它，继续吗？');
                        if (!ok) return;
                    }
                } catch (e) {}
                try {
                    // 将文件内容写入编辑器
                    window.editor && window.editor.setValue(text);
                    window.editor && window.editor.focus();
                    saveStatus.textContent = '已加载本地文件';
                    // 更新当前文件名显示
                    try { currentFilename = f.name || currentFilename; fileTitle.textContent = currentFilename; setDirty(false); } catch (e) {}
                    // 根据扩展设定语言模式（若 Monaco 已就绪）
                    try {
                        const name = f.name || '';
                        const ext = name.split('.').pop().toLowerCase();
                        let lang = 'plaintext';
                        if (ext === 'c' || ext === 'h') lang = 'c';
                        else if (ext === 'cpp' || ext === 'cxx' || ext === 'hpp' || ext === 'hxx') lang = 'cpp';
                        else lang = 'plaintext';
                        if (window.monaco && window.editor && window.editor.getModel) {
                            monaco.editor.setModelLanguage(window.editor.getModel(), lang);
                        }
                    } catch (e) {}
                } catch (e) {}
                // 清空选择以便再次打开同一文件
                fileInput.value = '';
            };
            reader.readAsText(f);
        });

        // 另存为：下载当前编辑器内容为文件
        function saveAsFile() {
            try {
                const content = window.editor ? window.editor.getValue() : '';
                const name = currentFilename || 'main.c';
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 5000);
                saveStatus.textContent = '已下载 ' + name;
                // 另存为并不改变脏状态
            } catch (e) {
                console.error('另存为失败', e);
                alert('另存为失败：' + (e && e.message));
            }
        }
        saveAsBtn.addEventListener('click', saveAsFile);

        // 全屏按钮（修复：提供回退以防 .frame 未定义）
        const fsBtn = document.getElementById('fsBtn');
        fsBtn.addEventListener('click', () => {
            // 首选 .frame，其次回退到 .app，再回退到 documentElement
            const el = document.querySelector('.frame') || document.querySelector('.app') || document.documentElement;
            if (!document.fullscreenElement) {
                el.requestFullscreen?.();
            } else {
                document.exitFullscreen?.();
            }
        });

        // 页面卸载时自动保存（可选）
        window.addEventListener('beforeunload', () => {
            if (window.editor) localStorage.setItem('deepseek_saved_c', window.editor.getValue());
        });

        // 页面加载时：设置编辑器为暗黑主题（若 monaco 已加载则在创建时设置，若晚加载则尝试设置）
        window.addEventListener('load', () => {
            try { if (window.monaco) monaco.editor.setTheme('vs-dark'); } catch (e) {}
            // 初始时隐藏侧栏恢复按钮（默认展开）
            document.getElementById('sidebarToggle').style.display = 'none';

            // 调整侧栏上下边界以避免遮挡头部和底部工具条
            try { /* 调整将在下面的调整函数中完成 */ } catch (e) {}

            // 确保 Monaco 布局正确——在某些浏览器/布局中首次渲染时需要手动触发 layout
            try { window.editor && window.editor.layout(); } catch (e) {}

            // 绑定全屏按钮（容错）：如果之前绑定失败，这里再绑定一次
            try {
                const fs = document.getElementById('fsBtn');
                if (fs && !fs.dataset._fsBound) {
                    fs.addEventListener('click', () => {
                        const el = document.querySelector('.frame') || document.querySelector('.app') || document.documentElement;
                        if (!document.fullscreenElement) {
                            el.requestFullscreen?.();
                        } else {
                            document.exitFullscreen?.();
                        }
                    });
                    fs.dataset._fsBound = '1';
                }
            } catch (e) {}

            // 确保复选框与其他交互元素可以响应（有时被早期脚本或覆盖元素阻塞）
            try { const useWasmEl = document.getElementById('useWasm'); if (useWasmEl) useWasmEl.style.pointerEvents = 'auto'; } catch(e) {}
        });

        // 当窗口尺寸变化时，重新布局编辑器以适配容器大小
        window.addEventListener('resize', () => { try { window.editor && window.editor.layout(); } catch (e) {} });
    </script>

        <script src="/projects/compiler/changelog.js" defer></script>
</body>
</html>